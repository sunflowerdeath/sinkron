{"version":3,"file":"server.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAOA;AAOA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AAAA;AAUA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAGA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;ACxJA;AACA;AAEA;AAAA;AAMA;AACA;AACA;AAAA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AAqBA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAYA;AACA;AAEA;AACA;AACA;AAKA;AAEA;AACA;AACA;AAaA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAKA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClLA;AAGA;AACA;AAUA;AAaA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAUA;AACA;AACA;AACA;AAAA;AACA;AACA;AAIA;AAAA;AACA;AACA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AAGA;AACA;AAAA;AAGA;AACA;AACA;AAAA;AAGA;AAEA;AAAA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAAA;AACA;AAAA;AAKA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;ACpOA;AAwCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;;;;;;;;;;;AC5FA;AAIA;AACA;AAGA;AAAA;AAKA;AAAA;AAKA;AAAA;AAKA;AAAA;AAIA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAEA;;;;;;;;;;;;;;;;;;AChCA;AAIA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AAIA;AAAA;AAKA;AAAA;AAKA;AAAA;AAIA;AACA;AAEA;;;;;;;;;;;;;;;;;;AClCA;AAmCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAIA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;AC5FA;AAEA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAHA;AAAA;AAUA;AAAA;AACA;AACA;AAEA;AAEA;AAAA;AAIA;AAAA;AACA;AAAA;AAIA;AAAA;AACA;AAAA;AAIA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AACA;AAAA;AAEA;AAEA;;;;;;;;;;;;;;;;;ACpEA;AAEA;AAGA;AAGA;AAGA;AAGA;AAEA;AAhBA;AAAA;AA+CA;AACA;AACA;AACA;AAHA;AAAA;;;;;;;;;;;;;;;;AC3CA;AAAA;AACA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;ACTA;AACA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AAMA;AAGA;AAIA;AACA;AAEA;AAkDA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAKA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AAAA;AAMA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AACA;AACA;AAEA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAIA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AAAA;AACA;AAAA;AAOA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAMA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAGA;AAAA;AACA;AAAA;AAMA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AAAA;AAMA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiCA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAIA;AAEA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;AAMA;AAAA;AACA;AAOA;AAAA;AACA;AACA;AACA;AAMA;AAAA;AACA;AAMA;AAAA;AACA;AACA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAKA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1hBA;AACA;AAIA;AAQA;AAUA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAAA;AAKA;AAEA;AALA;AAAA;AACA;AAOA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAGA;AAIA;AAQA;AAAA;AACA;AAEA;AAEA;AAAA;AAIA;AACA;AAMA;AAAA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAGA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AAAA;AAGA;AACA;AAAA;AAGA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AAmBA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAIA;AACA;AACA;AAAA;AAEA;AAAA;AAGA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAEA;AAEA;;;;;;;;;;;;;;;;ACrWA;AAAA;AACA;AAEA;AAEA;;;;;;;;;;;ACTA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AAKA;AASA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAIA;AAyBA;AAEA","sources":["webpack://sinkron/./src/paper/app.ts","webpack://sinkron/./src/paper/controller/index.ts","webpack://sinkron/./src/paper/controller/spaces.ts","webpack://sinkron/./src/paper/controller/users.ts","webpack://sinkron/./src/paper/entities.ts","webpack://sinkron/./src/paper/routes/invites.ts","webpack://sinkron/./src/paper/routes/login.ts","webpack://sinkron/./src/paper/routes/spaces.ts","webpack://sinkron/./src/sinkron/entities.ts","webpack://sinkron/./src/sinkron/permissions.ts","webpack://sinkron/./src/sinkron/protocol.ts","webpack://sinkron/./src/sinkron/result.ts","webpack://sinkron/./src/sinkron/server.ts","webpack://sinkron/./src/sinkron/sinkron.ts","webpack://sinkron/./src/sinkron/ws.ts","webpack://sinkron/./src/utils/result.ts","webpack://sinkron/external commonjs \"@automerge/automerge\"","webpack://sinkron/external commonjs \"@koa/router\"","webpack://sinkron/external commonjs \"ajv\"","webpack://sinkron/external commonjs \"koa\"","webpack://sinkron/external commonjs \"koa-bodyparser\"","webpack://sinkron/external commonjs \"koa-tree-router\"","webpack://sinkron/external commonjs \"lodash\"","webpack://sinkron/external commonjs \"pino\"","webpack://sinkron/external commonjs \"typeorm\"","webpack://sinkron/external commonjs \"ws\"","webpack://sinkron/external node-commonjs \"http\"","webpack://sinkron/webpack/bootstrap","webpack://sinkron/webpack/runtime/compat get default export","webpack://sinkron/webpack/runtime/define property getters","webpack://sinkron/webpack/runtime/hasOwnProperty shorthand","webpack://sinkron/webpack/runtime/make namespace object","webpack://sinkron/./src/server.ts"],"sourcesContent":["import { createServer } from 'http'\nimport type { Server, ClientRequest, IncomingMessage } from 'http'\n\nimport cookie from 'cookie'\nimport Ajv, { JSONSchemaType } from 'ajv'\nimport {\n    EntitySchema,\n    DataSource,\n    Repository,\n    MoreThan,\n    MoreThanOrEqual,\n    EntityManager\n} from 'typeorm'\n\nimport Koa from 'koa'\nimport koaBodyParser from 'koa-bodyparser'\nimport Router from 'koa-tree-router'\n\nimport { Sinkron, SinkronServer } from '../sinkron/server'\n\nimport { Controller } from './controller'\nimport type { User, Space, SpaceMember } from './entities'\nimport { entities } from './entities'\n\nimport loginRouter from \"./routes/login\"\nimport spacesRouter from \"./routes/spaces\"\nimport invitesRouter from \"./routes/invites\"\n\nconst credentialsSchema = {\n    type: 'object',\n    properties: {\n        name: { type: 'string' },\n        password: { type: 'string' }\n    },\n    required: ['name', 'password'],\n    additionalProperties: false\n}\n\ntype AppProps = {\n    sinkron: Sinkron\n    host?: string\n    port?: number\n}\n\nclass App {\n    sinkron: Sinkron\n    sinkronServer: SinkronServer\n    http: Server\n    host?: string\n    port?: number\n    db: DataSource\n    controller: Controller\n\n    constructor(props: AppProps) {\n        const { sinkron, host, port } = props\n        this.host = host\n        this.port = port\n\n        this.db = new DataSource({\n            type: 'better-sqlite3',\n            database: ':memory:',\n            entities,\n            synchronize: true,\n            logging: ['query', 'error']\n        })\n\n        this.sinkron = sinkron\n        this.sinkronServer = new SinkronServer({ sinkron })\n\n        this.controller = new Controller(this.db, sinkron)\n\n        const koa = this.createApp()\n\n        const authenticate = async (\n            request: IncomingMessage\n        ): Promise<string | undefined> => {\n            const token = request.url!.slice(1)\n            const res = await this.controller.users.verifyAuthToken(token)\n            if (res.isOk && res.value !== null) {\n                return res.value.userId\n            } else {\n                return undefined\n            }\n        }\n\n        this.http = createServer(koa.callback())\n        this.http.on('upgrade', (request, socket, head) => {\n            authenticate(request).then((userId) => {\n                if (userId === undefined) {\n                    socket.write('HTTP/1.1 401 Unauthorized\\r\\n\\r\\n')\n                    socket.destroy()\n                    return\n                }\n                this.sinkronServer.ws.handleUpgrade(\n                    request,\n                    socket,\n                    head,\n                    (ws) => {\n                        this.sinkronServer.ws.emit('connection', ws, request)\n                    }\n                )\n            })\n        })\n    }\n\n    async init() {\n        await this.db.initialize()\n    }\n\n    createApp() {\n        const app = new Koa()\n\n        app.keys = ['VERY SECRET KEY']\n        app.use(koaBodyParser())\n\n        app.use(loginRouter(this.controller).routes())\n\n        const requireAuth = async (ctx, next) => {\n            const token = ctx.cookies.get('token')\n            if (token) {\n                const res = await this.controller.users.verifyAuthToken(token)\n                if (res.isOk && res !== null) {\n                    ctx.token = res.value\n                    await next()\n                    return\n                }\n            }\n            ctx.status = 401\n            ctx.end('Unauthorized')\n        }\n\n        const router = new Router()\n        router.use(requireAuth)\n        router.get('/profile', async (ctx) => {\n            const token = ctx.token\n            const res = await this.controller.users.getUserProfile(token.userId)\n            if (!res.isOk) throw 'hz'\n            ctx.body = res.value\n        })\n        router.use(spacesRouter(this.controller).routes())\n        router.use(invitesRouter(this.controller).routes())\n\n        app.use(router.routes())\n\n        return app\n    }\n\n    async start() {\n        this.http.listen({ host: this.host, port: this.port }, () => {\n            console.log(`Server started at ${this.host}:${this.port}`)\n            // this.logger.info(`Server started at ${this.host}:${this.port}`)\n        })\n    }\n}\n\nexport { App }\n","import { DataSource } from 'typeorm'\nimport { Sinkron } from \"../../sinkron/sinkron\"\n\nimport { UsersController } from \"./users\"\nimport { SpacesController } from \"./spaces\"\n\nclass Controller {\n    sinkron: Sinkron\n    users: UsersController \n    spaces: SpacesController \n\n    constructor(db: DataSource, sinkron: Sinkron) {\n        this.sinkron = sinkron\n        this.users = new UsersController(db, this)\n        this.spaces = new SpacesController(db, this)\n    }\n}\n\nexport { Controller }\n","import { EntitySchema, DataSource, Repository } from 'typeorm'\nimport { Raw } from 'typeorm'\n\nimport { AuthToken, User, Space, SpaceRole, SpaceMember } from '../entities'\nimport { Controller } from './index'\n\nimport { Permissions, Permission } from '../../sinkron/permissions'\nimport { Sinkron } from '../../sinkron/sinkron'\nimport { Result, ResultType } from '../../sinkron/result'\nimport { ErrorCode } from '../../sinkron/protocol'\n\ntype RequestError = {\n    code: ErrorCode\n    details: Object\n    message: string\n}\n\ntype CreateSpaceProps = {\n    ownerId: string\n    name: string\n}\n\ntype AddMemberProps = {\n    userId: string\n    spaceId: string\n    role: SpaceRole\n}\n\ntype UserSpaces = { id: string; name: string; role: SpaceRole }[]\n\nclass SpacesController {\n    constructor(db: DataSource, c: Controller) {\n        this.db = db\n        this.controller = c\n        this.sinkron = c.sinkron\n\n        this.users = db.getRepository('user')\n        this.spaces = db.getRepository('space')\n        this.members = db.getRepository('space_member')\n    }\n\n    db: DataSource\n    controller: Controller\n    sinkron: Sinkron\n\n    users: Repository<User>\n    spaces: Repository<Space>\n    members: Repository<SpaceMember>\n\n    async create(\n        props: CreateSpaceProps\n    ): Promise<ResultType<Space, RequestError>> {\n        const { ownerId, name } = props\n\n        const data = { name, ownerId }\n        const res = await this.spaces.insert(data)\n        const space = {\n            ...data,\n            ...res.generatedMaps[0]\n        } as Space\n\n        const col = `spaces/${space.id}`\n\n        await this.sinkron.createGroup(`${col}/readonly`)\n        await this.sinkron.createGroup(`${col}/editor`)\n        await this.sinkron.createGroup(`${col}/admin`)\n\n        /*\n        const p = new Permissions()\n        p.add('group:${col}/readonly', [Permission.read])\n        p.add('group:${col}/editor', [Permission.read, Permission.write])\n        p.add('group:${col}/admin', [\n            Permission.read,\n            Permission.write,\n            Permission.admin\n        ])\n        */\n\n        await this.sinkron.createCollection(col)\n\n        await this.members.insert({\n            userId: ownerId,\n            spaceId: space.id,\n            role: 'admin'\n        })\n        await this.sinkron.addMemberToGroup(ownerId, `spaces/${space.id}/admin`)\n\n        return Result.ok(space)\n    }\n\n    async delete(id: string): Promise<ResultType<true, RequestError>> {\n        const res = await this.spaces.delete(id)\n        if (res.affected === 0) {\n            return Result.err({\n                code: ErrorCode.NotFound,\n                message: 'Space not found',\n                details: { id }\n            })\n        }\n\n        const col = `spaces/${id}`\n        await this.sinkron.deleteCollection(col)\n\n        return Result.ok(true)\n    }\n\n    async addMember(props: AddMemberProps) {\n        const { userId, spaceId, role } = props\n\n        const cnt1 = await this.spaces.countBy({ id: spaceId })\n        if (cnt1 === 0) {\n            return Result.err({\n                code: ErrorCode.NotFound,\n                message: 'Space not found',\n                details: { id: spaceId }\n            })\n        }\n\n        const cnt2 = await this.users.countBy({ id: userId })\n        if (cnt2 === 0) {\n            return Result.err({\n                code: ErrorCode.NotFound,\n                message: 'User not found',\n                details: { id: userId }\n            })\n        }\n\n        // TODO check if already added\n\n        await this.members.insert({ userId, spaceId, role })\n        await this.sinkron.addMemberToGroup(userId, `spaces/${spaceId}/${role}`)\n    }\n\n    async getUserSpaces(\n        userId: string\n    ): Promise<ResultType<UserSpaces, RequestError>> {\n        const cnt = await this.users.countBy({ id: userId })\n        if (cnt === 0) {\n            return Result.err({\n                code: ErrorCode.NotFound,\n                message: 'User not found',\n                details: { id: userId }\n            })\n        }\n\n        const res = await this.members.find({\n            where: { userId },\n            relations: ['space']\n        })\n        const spaces = res.map((m) => ({\n            id: m.spaceId,\n            name: m.space.name,\n            role: m.role\n        }))\n        return Result.ok(spaces)\n    }\n\n    // update space member\n\n    // remove member from space\n\n    /*\n    async sendInvite(userId: string, role: SpaceRole) {\n        this.invites.insert({\n            to: userId,\n            role: SpaceRole\n        })\n    }\n\n    async acceptInvite(inviteId: string) {\n        // this.addMemberToSpace(...)\n    }\n\n    async declineInvite(inviteId: string) {}\n\n    async cancelInvite(inviteId: string) {}\n    */\n}\n\nexport { SpacesController }\n","import { EntitySchema, DataSource, Repository } from 'typeorm'\nimport { Raw } from 'typeorm'\n\nimport { AuthToken, User, Space, SpaceRole, SpaceMember } from '../entities'\nimport { Result, ResultType } from '../../utils/result'\nimport { ErrorCode } from '../../sinkron/protocol'\n\nimport { Controller } from './index'\n\ntype RequestError = {\n    code: ErrorCode\n    details: Object\n    message: string\n}\n\nconst maxTokensPerUser = 10\n\ntype AuthTokenProps = {\n    userId: string\n    client?: string\n    expiration?: number\n}\n\ntype Profile = {\n    id: string\n    spaces: { id: string; role: string }[]\n}\n\nclass UsersController {\n    constructor(db: DataSource, c: Controller) {\n        this.controller = c\n        this.db = db\n        this.users = db.getRepository('user')\n        this.tokens = db.getRepository('token')\n    }\n\n    controller: Controller\n    db: DataSource\n    users: Repository<User>\n    tokens: Repository<AuthToken>\n\n    async createUser(\n        name: string,\n        password: string\n    ): Promise<ResultType<User, RequestError>> {\n        const data = { name, password, isDisabled: false }\n        const res = await this.users.insert(data)\n        const user = {\n            name,\n            isDisabled: false,\n            ...res.generatedMaps[0]\n        } as User\n\n        const res2 = await this.controller.spaces.create({\n            ownerId: user.id,\n            name: name\n        })\n        if (!res2.isOk) return res2\n\n        return Result.ok(user)\n    }\n\n    async deleteUser(id: string): Promise<ResultType<true, RequestError>> {\n        const res = await this.users.delete(id)\n        if (res.affected === 0) {\n            return Result.err({\n                code: ErrorCode.NotFound,\n                message: 'User not found',\n                details: { id }\n            })\n        } else {\n            // TODO delete tokens\n            return Result.ok(true)\n        }\n    }\n\n    async getUser(id: string): Promise<ResultType<User | null, RequestError>> {\n        const user = await this.users.findOne({\n            where: { id },\n            select: { id: true }\n        })\n        return Result.ok(user)\n    }\n\n    isTokenExpired(token: AuthToken): boolean {\n        const now = new Date()\n        return token.expiresAt === null || token.expiresAt > now\n    }\n\n    async _deleteExpiredTokens(user: string) {\n        await this.tokens.delete({\n            userId: user,\n            expiresAt: Raw((f) => `${f} NOT NULL AND ${f} < TIME('now')`)\n        })\n    }\n\n    async _deleteTokensOverLimit(user: string) {\n        const tokensOverLimit = await this.tokens.find({\n            select: { token: true },\n            where: { userId: user },\n            order: { lastAccess: 'DESC' },\n            skip: maxTokensPerUser\n        })\n        if (tokensOverLimit.length) {\n            await this.tokens.delete(tokensOverLimit.map((t) => t.token))\n        }\n    }\n\n    async issueAuthToken(\n        props: AuthTokenProps\n    ): Promise<ResultType<AuthToken, RequestError>> {\n        const { userId, client, expiration } = props\n\n        const count = await this.users.countBy({ id: userId })\n        if (count === 0) {\n            return Result.err({\n                code: ErrorCode.InvalidRequest,\n                message: 'User does not exist',\n                details: { id: userId }\n            })\n        }\n\n        const res = await this.tokens.insert({ userId })\n        const token = { userId, ...res.generatedMaps[0] } as AuthToken\n\n        this._deleteExpiredTokens(userId)\n        this._deleteTokensOverLimit(userId)\n\n        return Result.ok(token)\n    }\n\n    async deleteToken(token: string): Promise<ResultType<true, RequestError>> {\n        const res = await this.tokens.delete({ token })\n        if (res.affected === 0) {\n            return Result.err({\n                code: ErrorCode.NotFound,\n                message: 'Token not found',\n                details: { token }\n            })\n        } else {\n            return Result.ok(true)\n        }\n    }\n\n    async verifyAuthToken(\n        token: string\n    ): Promise<ResultType<AuthToken | null, RequestError>> {\n        const res = await this.tokens.findOne({\n            where: { token },\n            select: { token: true, userId: true, createdAt: true }\n        })\n\n        if (res === null) {\n            return Result.ok(null)\n        }\n\n        if (this.isTokenExpired(res)) {\n            this.tokens.delete({ token })\n            return Result.ok(null)\n        }\n\n        this.tokens.update({ token }, { lastAccess: new Date() })\n\n        return Result.ok(res)\n    }\n\n    async getUserTokens(\n        user: string,\n        activeOnly: boolean = false\n    ): Promise<ResultType<AuthToken[], RequestError>> {\n        const count = await this.users.countBy({ id: user })\n        if (count === 0) {\n            return Result.err({\n                code: ErrorCode.NotFound,\n                message: 'User not found',\n                details: { user }\n            })\n        }\n\n        await this._deleteExpiredTokens(user)\n\n        const tokens = await this.tokens.findBy({ userId: user })\n        return Result.ok(tokens)\n    }\n\n    async authorizeWithPassword(\n        name: string,\n        password: string\n    ): Promise<ResultType<AuthToken, RequestError>> {\n        const user = await this.users.findOne({\n            where: { name, isDisabled: false },\n            select: { id: true, password: true }\n        })\n        if (user === null || user.password !== password) {\n            return Result.err({\n                code: ErrorCode.InvalidRequest,\n                message: \"Couldn't authorize\",\n                details: { user }\n            })\n        }\n\n        const res = await this.issueAuthToken({ userId: user.id })\n        return res\n    }\n\n    async getUserProfile(\n        id: string\n    ): Promise<ResultType<Profile, RequestError>> {\n        const user = await this.users.findOne({\n            where: { id, isDisabled: false },\n            select: { id: true }\n        })\n\n        if (user === null) {\n            return Result.err({\n                code: ErrorCode.NotFound,\n                message: 'User not found',\n                details: { id }\n            })\n        }\n        const getSpacesRes = await this.controller.spaces.getUserSpaces(user.id)\n        if (!getSpacesRes.isOk) return getSpacesRes\n\n        const profile = { ...user, spaces: getSpacesRes.value! } as Profile\n        return Result.ok(profile)\n    }\n}\n\nexport { UsersController }\n","import { EntitySchema } from 'typeorm'\n\nexport type User = {\n    id: string\n    createdAt: Date\n    isDisabled: boolean\n    name: string\n    password: string\n}\n\nexport type AuthToken = {\n    token: string\n    userId: string\n    user: User\n    createdAt: Date\n    expiresAt: Date | null\n    lastAccess: Date\n    client: string\n}\n\nexport type Space = {\n    id: string\n    name: string\n    owner: User\n    ownerId: string\n    createdAt: Date\n}\n\nexport type SpaceRole = 'readonly' | 'editor' | 'admin'\n\nexport type SpaceMember = {\n    id: string\n    space: Space\n    user: User\n    spaceId: string\n    userId: string\n    role: SpaceRole\n    createdAt: Date\n}\n\nconst UserEntity = new EntitySchema<User>({\n    name: 'user',\n    columns: {\n        id: { type: String, primary: true, generated: 'uuid' },\n        createdAt: { type: Date, createDate: true },\n        isDisabled: { type: Boolean },\n        name: { type: String, unique: true },\n        password: { type: String }\n    }\n})\n\nconst AuthTokenEntity = new EntitySchema<AuthToken>({\n    name: 'token',\n    columns: {\n        token: { type: String, primary: true, generated: 'uuid' },\n        userId: { type: String },\n        createdAt: { type: Date, createDate: true },\n        expiresAt: { type: Date, nullable: true },\n        lastAccess: { type: Date, createDate: true },\n        client: { type: String, nullable: true }\n    },\n    relations: {\n        user: { type: 'many-to-one', target: 'user' }\n    }\n})\n\nconst SpaceEntity = new EntitySchema<Space>({\n    name: 'space',\n    columns: {\n        id: { type: String, primary: true, generated: 'uuid' },\n        name: { type: String },\n        createdAt: { type: Date, createDate: true }\n    }\n})\n\nconst SpaceMemberEntity = new EntitySchema<SpaceMember>({\n    name: 'space_member',\n    columns: {\n        id: { type: String, primary: true, generated: 'uuid' },\n        userId: { type: String },\n        spaceId: { type: String },\n        role: { type: String },\n        createdAt: { type: Date, createDate: true }\n    },\n    relations: {\n        space: { type: 'many-to-one', target: 'space' },\n        user: { type: 'many-to-one', target: 'user' }\n    }\n})\n\nconst entities = [UserEntity, AuthTokenEntity, SpaceEntity, SpaceMemberEntity]\n\nexport { entities }\n","import Router from '@koa/router'\n\nimport { Controller } from \"../controller\"\n\nconst invitesRouter = (controller: Controller) => {\n    const router = new Router()\n\n    // send invite to a user\n    router.post('/invites/new', () => {\n        // TODO\n    })\n\n    // accept invite\n    router.post('/invites/:id/accept', () => {\n        // TODO\n    })\n\n    // reject invite\n    router.post('/invites/:id/reject', () => {\n        // TODO\n    })\n\n    // cancel invite\n    router.post('/invites/:id/cancel', () => {\n        // TODO\n    })\n\n    return router\n}\n\nexport default invitesRouter\n","import Router from 'koa-tree-router'\n\nimport { Controller } from \"../controller\"\n\nconst loginRouter = (controller: Controller) => {\n    const router = new Router()\n\n    router.post('/login', async (ctx) => {\n        ctx.type = 'application/json'\n        const { name, password } = ctx.request.body\n        const res = await controller.users.authorizeWithPassword(\n            name,\n            password\n        )\n        if (res.isOk) {\n            const token = res.value\n            ctx.cookies.set('token', token.token, { httpOnly: false })\n            const profileRes = await controller.users.getUserProfile(\n                token.userId\n            )\n            if (!profileRes.isOk) throw 'hz'\n            ctx.body = profileRes.value\n        } else {\n            ctx.cookies.set('token')\n            ctx.status = 500\n            ctx.body = { error: { message: 'Invalid name or password' } }\n        }\n    })\n\n    return router\n}\n    \nexport default loginRouter\n","import Router from '@koa/router'\n\nimport { Controller } from \"../controller\"\n\nconst spacesRouter = (controller: Controller) => {\n    const router = new Router()\n\n    // create space\n    router.post('/spaces/new', (ctx) => {\n        const { name } = ctx.request.body\n        controller.spaces.create({\n            name,\n            ownerId: ctx.token.userId\n        })\n    })\n\n    // get list of members\n    router.get('/spaces/:id/members', () => {\n        // TODO\n    })\n\n    // update member of a space (change role)\n    router.post('/spaces/:idd/members/:member/update', () => {\n        // TODO\n    })\n\n    // remove member from a space\n    router.post('/spaces/:idd/members/:member/remove', () => {\n        // TODO\n    })\n\n    return router\n}\n\nexport default spacesRouter\n\n","import { EntitySchema } from 'typeorm'\n\nexport type Document = {\n    id: string\n    createdAt: Date\n    updatedAt: Date\n    rev: number\n    data: Uint8Array | null\n    owner: string\n    permissions: string\n    isDeleted: boolean\n    colId: string\n    col: Collection\n    colrev: number\n}\n\nexport type Collection = {\n    id: string\n    createdAt: Date\n    updatedAt: Date\n    colrev: number\n    owner: string\n}\n\nexport type Group = {\n    id: string\n    name: string\n}\n\nexport type GroupMember = {\n    id: string\n    user: string\n    group: Group\n}\n\nconst DocumentEntity = new EntitySchema<Document>({\n    name: 'document',\n    columns: {\n        id: { type: String, primary: true },\n        rev: { type: Number },\n        data: { type: 'blob', nullable: true },\n        createdAt: { type: Date, createDate: true },\n        updatedAt: { type: Date, updateDate: true },\n        isDeleted: { type: Boolean },\n        permissions: { type: String },\n        colrev: { type: Number }, // index ?\n        colId: { type: String } // index ?\n    },\n    relations: {\n        // owner: { type: \"many-to-one\", target: \"user\" },\n        col: { type: 'many-to-one', target: 'collection' }\n    }\n})\n\nconst CollectionEntity = new EntitySchema<Collection>({\n    name: 'collection',\n    columns: {\n        id: { type: 'uuid', primary: true, generated: 'uuid' },\n        createdAt: { type: Date, createDate: true },\n        updatedAt: { type: Date, updateDate: true },\n        colrev: { type: Number }\n    }\n    // relations: {\n    // entries: { type: \"one-to-many\", target: \"entry\" },\n    // },\n})\n\nconst GroupEntity = new EntitySchema<Group>({\n    name: 'group',\n    columns: {\n        id: { type: 'uuid', primary: true, generated: 'uuid' }\n    }\n})\n\nconst GroupMemberEntity = new EntitySchema<GroupMember>({\n    name: 'group_member',\n    columns: {\n        id: { type: 'uuid', primary: true, generated: 'uuid' },\n        user: { type: String }\n    },\n    relations: {\n        group: { type: 'many-to-one', target: 'group' }\n    }\n})\n\nconst entities = [\n    DocumentEntity,\n    CollectionEntity,\n    GroupEntity,\n    GroupMemberEntity\n]\n\nexport { entities }\n","import { uniq } from 'lodash'\n\nconst Role = {\n    any: () => 'any',\n    user: (id: string) => `user:${id}`,\n    group: (id: string) => `group:${id}`\n}\n\nexport enum Permission {\n    read = 'read',\n    write = 'write',\n    admin = 'admin'\n}\n\ntype PermissionsTable = {\n    -readonly [key in keyof typeof Permission]: string[]\n}\n\nconst emptyPermissionsTable = {\n    read: [],\n    write: [],\n    admin: []\n}\n\nclass Permissions {\n    table: PermissionsTable\n\n    constructor(table?: PermissionsTable) {\n        this.table = table || emptyPermissionsTable\n    }\n\n    // Adds permission to the table\n    add(permission: Permission, role: string) {\n        this.table[permission] = uniq([role, ...this.table[permission]])\n    }\n\n    // Removes permission from the table\n    remove(permission: Permission, role: string) {\n        this.table[permission] = this.table[permission].filter(\n            (r) => r !== role\n        )\n    }\n\n    // Checks if user has permission (issued directly on him or on his\n    // group or group role)\n    check(user: any, permission: Permission) {\n        const roles = this.table[permission]\n        for (let i in roles) {\n            const role = roles[i]\n            if (role === 'any') return true\n            let match = role.match(/^user:(.+)$/)\n            if (match && user.id === match[0]) return true\n            match = role.match(/^group:(.+)$/)\n            if (match && user.groups.includes(match[0])) return true\n        }\n        return false\n    }\n\n    stringify() {\n        return JSON.stringify(this.table)\n    }\n\n    static parse(str: string) {\n        const table = JSON.parse(str)\n        return new Permissions(table)\n    }\n}\n\nexport { emptyPermissionsTable, Permissions }\n","export enum ErrorCode {\n    // Invalid request format\n    InvalidRequest = \"invalid_request\",\n\n    // User could not be authenticated, connection will be closed\n    AuthenticationFailed = \"auth_failed\",\n\n    // User doesn't have permission to perform the operation\n    AccessDenied = \"access_denied\",\n\n    // Operation cannot be performed\n    UnprocessableRequest = \"unprocessable_request\",\n\n    // Requested entity not found\n    NotFound = \"not_found\",\n\n    InternalServerError = \"internal_server_error\",\n}\n\nexport type SyncMessage = {\n    kind: \"sync\"\n    token: string\n    col: string\n    colrev?: number\n}\n\nexport type DocMessage = {\n    kind: \"doc\"\n    id: string\n    col?: string\n    data: string | null\n    createdAt: string // iso8601 time\n    updatedAt: string // iso8601 time\n}\n\nexport type SyncErrorMessage = {\n    kind: \"sync_error\"\n    col: string\n    code: ErrorCode\n}\n\nexport type SyncCompleteMessage = {\n    kind: \"sync_complete\"\n    col: string\n    colrev: number\n}\n\nexport enum Op {\n    Create = \"+\",\n    Modify = \"M\",\n    Delete = \"-\",\n}\n\ninterface BaseChangeMessage {\n    kind: \"change\"\n\n    // These fields are sent by both client and server:\n    col: string\n    id: string\n    changeid: string\n\n    // These fields are sent by server in the response to the change:\n    colrev?: number\n    createdAt?: string // iso8601 time\n    updatedAt?: string // iso8601 time\n}\n\nexport interface CreateMessage extends BaseChangeMessage {\n    op: Op.Create\n    data: string\n}\n\nexport interface ModifyMessage extends BaseChangeMessage {\n    op: Op.Modify\n    data: string[]\n}\n\nexport interface DeleteMessage extends BaseChangeMessage {\n    op: Op.Delete\n}\n\nexport type ChangeMessage = CreateMessage | ModifyMessage | DeleteMessage\n\nexport type ErrorMessage = {\n    kind: \"error\"\n    code: ErrorCode\n    id: string\n    changeid: string\n}\n\nexport type ClientMessage = SyncMessage | ChangeMessage\n\nexport type ServerMessage =\n    | SyncErrorMessage\n    | SyncCompleteMessage\n    | DocMessage\n    | ChangeMessage\n    | ErrorMessage\n","export type ResultType<T, E = Error> =\n    | { isOk: true; value: T }\n    | { isOk: false; error: E }\n\nconst Result = {\n    ok: <T, E>(value: T): ResultType<T, E> => ({ isOk: true, value }),\n    err: <T, E>(error: E): ResultType<T, E> => ({ isOk: false, error })\n}\n\nexport { Result }\n","import { Sinkron } from \"./sinkron\"\nimport { SinkronServer } from \"./ws\"\nimport { ChangeMessage } from \"./protocol\"\n\nexport { Sinkron, SinkronServer }\n","import {\n    EntitySchema,\n    DataSource,\n    Repository,\n    MoreThan,\n    MoreThanOrEqual,\n    EntityManager\n} from 'typeorm'\nimport { without, remove, isEqual, uniq } from 'lodash'\nimport { v4 as uuidv4 } from 'uuid'\nimport * as Automerge from '@automerge/automerge'\nimport pino from 'pino'\n\nimport { entities } from './entities'\nimport type { Document, Collection, Group, GroupMember } from './entities'\n\n// import { generatePasswordHash, validatePasswordHash } from './passwordHash'\nimport { Result, ResultType } from './result'\nimport { emptyPermissionsTable } from './permissions'\nimport {\n    ErrorCode,\n    SyncMessage,\n    SyncErrorMessage,\n    SyncCompleteMessage,\n    Op,\n    ChangeMessage,\n    ModifyMessage,\n    CreateMessage,\n    DeleteMessage,\n    ErrorMessage,\n    DocMessage,\n    ClientMessage\n} from './protocol'\n\ntype ChangeHandler = (msg: ChangeMessage) => void\n\ntype CreateDocumentProps = {\n    id: string\n    data: Uint8Array\n    permissions: Permissions\n    col?: string\n}\n\ntype UpdateDocumentProps = {\n    id: string\n    changes: Uint8Array[]\n    permissions: Permissions\n}\n\ntype UpdateDocumentWithCallbackProps = {\n    id: string\n    callback: (doc: any) => void\n}\n\ntype ChangedDocuments = {\n    col: string\n    colrev: number\n    documents: Document[]\n}\n\ntype Credentials = { name: string; password: string }\n\ntype AuthResult = { token: string; user: string }\n\nexport type RequestError = { code: ErrorCode; details?: string }\n\ninterface SinkronProps {\n    dbPath: string\n}\n\nclass Sinkron {\n    constructor(props: SinkronProps) {\n        const { dbPath } = props\n        this.db = new DataSource({\n            type: 'better-sqlite3',\n            database: dbPath,\n            entities,\n            synchronize: true,\n            logging: ['query', 'error']\n        })\n        this.models = {\n            documents: this.db.getRepository('document'),\n            collections: this.db.getRepository('collection'),\n            groups: this.db.getRepository('group'),\n            members: this.db.getRepository('group_member')\n        }\n    }\n\n    db: DataSource\n\n    models: {\n        documents: Repository<Document>\n        collections: Repository<Collection>\n        groups: Repository<Group>\n        members: Repository<GroupMember>\n    }\n\n    async init() {\n        await this.db.initialize()\n    }\n\n    getModels(m: EntityManager) {\n        return {\n            documents: m.getRepository('document'),\n            collections: m.getRepository('collection'),\n            groups: m.getRepository('group'),\n            members: m.getRepository('group_member')\n        }\n    }\n\n    async getDocumentTr(m: EntityManager, id: string) {\n        const models = this.getModels(m)\n        const select = {\n            id: true,\n            rev: true,\n            data: true,\n            colId: true,\n            createdAt: true,\n            updatedAt: true\n        }\n        const res = await models.documents.findOne({\n            where: { id },\n            select\n        })\n        return res as Document | null\n    }\n\n    async getColEntityTr(\n        m: EntityManager,\n        col: string\n    ): Promise<Collection | null> {\n        const models = this.getModels(m)\n        const colEntity = await models.collections.findOne({\n            where: { id: col },\n            select: { id: true, colrev: true }\n        })\n        return colEntity as Collection | null\n    }\n\n    async createCollectionTr(\n        m: EntityManager,\n        id: string\n    ): Promise<ResultType<Collection, RequestError>> {\n        const models = this.getModels(m)\n        const count = await models.collections.countBy({ id })\n        if (count > 0) {\n            return Result.err({\n                code: ErrorCode.InvalidRequest,\n                details: 'Duplicate id'\n            })\n        }\n        await models.collections.insert({ id, colrev: 1 })\n        // TODO generated fields\n        const col = { id, colrev: 1 }\n        return Result.ok(col as Collection)\n    }\n\n    async syncCollectionTr(\n        m: EntityManager,\n        col: string,\n        colrev?: number\n    ): Promise<ResultType<ChangedDocuments, RequestError>> {\n        const models = this.getModels(m)\n\n        const colEntity = await this.getColEntityTr(m, col)\n        if (colEntity === null) return Result.err({ code: ErrorCode.NotFound })\n\n        const result = { col, colrev: colEntity.colrev }\n\n        const select = {\n            id: true,\n            data: true,\n            colrev: true,\n            createdAt: true,\n            updatedAt: true\n        }\n\n        if (colrev === undefined) {\n            // Get all documents except deleted\n            const documents = (await models.documents.find({\n                where: { colId: col, isDeleted: false },\n                select\n            })) as Document[]\n            return Result.ok({ ...result, documents })\n        }\n\n        if (colrev < 0 || colrev > colEntity.colrev) {\n            return Result.err({\n                code: ErrorCode.InvalidRequest,\n                details: 'Invalid colrev'\n            })\n        }\n\n        if (colEntity.colrev === colrev) {\n            return Result.ok({ ...result, documents: [] })\n        }\n\n        // Get documents since provided colrev including deleted\n        const documentsRows = (await models.documents.find({\n            where: { colId: col, colrev: MoreThan(colrev) },\n            select: { ...select, isDeleted: true }\n        })) as Document[]\n        const documents = documentsRows.map((d) =>\n            d.isDeleted ? ({ id: d.id, data: null } as Document) : d\n        )\n        return Result.ok({ ...result, documents })\n    }\n\n    async createDocumentTr(\n        m: EntityManager,\n        id: string,\n        col: string,\n        data: Uint8Array\n    ): Promise<ResultType<Document, RequestError>> {\n        const models = this.getModels(m)\n\n        const docCnt = await models.documents.countBy({ id })\n        if (docCnt > 0) {\n            return Result.err({\n                code: ErrorCode.InvalidRequest,\n                details: 'Duplicate id'\n            })\n        }\n\n        const colEntity = await this.getColEntityTr(m, col)\n        if (colEntity === null) {\n            return Result.err({\n                code: ErrorCode.InvalidRequest,\n                details: 'Collection not found'\n            })\n        }\n\n        // increment colrev\n        const nextColrev = colEntity.colrev + 1\n        await models.collections.update(col, { colrev: nextColrev })\n\n        // create document\n        const doc = {\n            id,\n            data,\n            rev: 1,\n            colId: col,\n            isDeleted: false,\n            colrev: nextColrev,\n            // TODO real permissions\n            permissions: JSON.stringify(emptyPermissionsTable)\n        }\n        await models.documents.insert(doc)\n\n        const generated = await models.documents.findOne({\n            where: { id },\n            select: { createdAt: true, updatedAt: true }\n        })\n        const result = { ...doc, ...generated } as Document\n        return Result.ok(result)\n    }\n\n    async incrementColrevTr(\n        m: EntityManager,\n        id: string\n    ): Promise<ResultType<number, RequestError>> {\n        const models = this.getModels(m)\n        const col = await models.collections.findOneBy({ id })\n        if (col === null) {\n            return Result.err({\n                code: ErrorCode.InvalidRequest,\n                details: 'Collection not found'\n            })\n        }\n        const nextColrev = col.colrev + 1\n        await models.collections.update(id, { colrev: nextColrev })\n        return Result.ok(nextColrev)\n    }\n\n    async updateDocumentEntityTr(\n        m: EntityManager,\n        doc: Document,\n        update: Partial<Document>\n    ): Promise<ResultType<Document, RequestError>> {\n        const models = this.getModels(m)\n\n        const incrementColrevResult = await this.incrementColrevTr(m, doc.colId)\n        if (!incrementColrevResult.isOk) return incrementColrevResult\n        const nextColrev = incrementColrevResult.value\n\n        await models.documents.update(doc.id, { ...update, colrev: nextColrev })\n        const { updatedAt } = (await models.documents.findOne({\n            where: { id: doc.id },\n            select: { updatedAt: true }\n        }))!\n\n        return Result.ok({ ...doc, ...update, colrev: nextColrev, updatedAt })\n    }\n\n    async updateDocumentTr(\n        m: EntityManager,\n        id: string,\n        data: Uint8Array[] | null\n    ): Promise<ResultType<Document, RequestError>> {\n        const models = this.getModels(m)\n\n        const doc = await this.getDocumentTr(m, id)\n        if (doc === null) return Result.err({ code: ErrorCode.NotFound })\n        if (doc.data === null) {\n            return Result.err({\n                code: ErrorCode.InvalidRequest,\n                details: 'Unable to update deleted document'\n            })\n        }\n\n        // Delete document\n        if (data === null) {\n            const updateResult = await this.updateDocumentEntityTr(m, doc, {\n                data: null,\n                isDeleted: true\n            })\n            return updateResult\n        }\n\n        // TODO cache?\n        let automerge = Automerge.load(doc.data)\n        try {\n            ;[automerge] = Automerge.applyChanges(automerge, data)\n        } catch (e) {\n            return Result.err({\n                code: ErrorCode.InvalidRequest,\n                details: 'Unable to apply changes'\n            })\n        }\n        const nextData = Automerge.save(automerge)\n        const updateResult = await this.updateDocumentEntityTr(m, doc, {\n            data: nextData\n        })\n        return updateResult\n    }\n\n    async updateDocumentWithCallbackTr<T>(\n        m: EntityManager,\n        id: string,\n        cb: Automerge.ChangeFn<T>\n    ): Promise<ResultType<Document, RequestError>> {\n        const models = this.getModels(m)\n\n        const doc = await this.getDocumentTr(m, id)\n        if (doc === null) return Result.err({ code: ErrorCode.NotFound })\n        if (doc.data === null) {\n            return Result.err({\n                code: ErrorCode.InvalidRequest,\n                details: 'Unable to update deleted document'\n            })\n        }\n\n        let automerge = Automerge.load<T>(doc.data)\n        try {\n            automerge = Automerge.change(automerge, cb)\n        } catch (e) {\n            return Result.err({\n                code: ErrorCode.InternalServerError,\n                details: 'Unable to apply changes'\n            })\n        }\n        const nextData = Automerge.save(automerge)\n\n        return await this.updateDocumentEntityTr(m, doc, { data: nextData })\n    }\n\n    /*\n    async updateDocumentPermissionsTr(\n        m: EntityManager,\n        id: string,\n        callback: (p: Permissions) => void\n    ) {\n        const models = this.getModels(m)\n\n        const doc = await models.documents.findOne({\n            where: { id },\n            select: { id: true, rev: true, permissions: true },\n        })\n        if (doc === null) {\n            throw new Error(`Can't update, unknown id: ${id}`) // 404\n        }\n\n        const nextColrev = await this.incrementColrevTr(m, doc.colId)\n        const permissions = Permissions.parse(doc.permissions)\n        callback(permissions)\n        await models.documents.update(id!, {\n            permissions: permissions.stringify(),\n            colrev: nextColrev,\n        })\n        return { id, permissions: permissions.table, colrev: nextColrev }\n    }\n    */\n\n    // Public API\n    createCollection(\n        id: string\n    ): Promise<ResultType<Collection, RequestError>> {\n        return this.db.transaction((m) => this.createCollectionTr(m, id))\n    }\n\n    getCollection(id: string): Promise<Collection | null> {\n        return this.db.transaction(async (m) => {\n            const models = this.getModels(m)\n            const select = { id: true, colrev: true }\n            const colEntity = await models.collections.findOne({\n                where: { id },\n                select\n            })\n            return colEntity as Collection\n        })\n    }\n\n    async deleteCollection(\n        id: string\n    ): Promise<ResultType<true, RequestError>> {\n        // TODO\n        return Result.ok(true)\n    }\n\n    getDocument(id: string): Promise<Document | null> {\n        return this.db.transaction((m) => this.getDocumentTr(m, id))\n    }\n\n    syncCollection(\n        col: string,\n        colrev?: number\n    ): Promise<ResultType<ChangedDocuments, RequestError>> {\n        return this.db.transaction((m) => this.syncCollectionTr(m, col, colrev))\n    }\n\n    createDocument(\n        id: string,\n        col: string,\n        data: Uint8Array\n    ): Promise<ResultType<Document, RequestError>> {\n        return this.db.transaction((tr) =>\n            this.createDocumentTr(tr, id, col, data)\n        )\n    }\n\n    updateDocument(\n        id: string,\n        data: Uint8Array[] | null\n    ): Promise<ResultType<Document, RequestError>> {\n        return this.db.transaction((m) => this.updateDocumentTr(m, id, data))\n    }\n\n    updateDocumentWithCallback<T>(\n        id: string,\n        cb: Automerge.ChangeFn<T>\n    ): Promise<ResultType<Document, RequestError>> {\n        return this.db.transaction((m) =>\n            this.updateDocumentWithCallbackTr(m, id, cb)\n        )\n    }\n\n    deleteDocument(id: string): Promise<ResultType<Document, RequestError>> {\n        return this.updateDocument(id, null)\n    }\n\n    /*\n    updateDocumentPermissions(id: string, callback: (p: Permissions) => void) {\n        return this.db.transaction((m) =>\n            this.updateDocumentPermissionsTr(m, id, callback)\n        )\n    }\n    */\n\n    // checkDocumentPermissions({ id, ... }) : Promise<boolean>\n\n    async createGroup(id: string): Promise<ResultType<Group, RequestError>> {\n        return this.db.transaction(async (m) => {\n            const models = this.getModels(m)\n            const count = await models.collections.countBy({ id })\n            if (count > 0) {\n                return Result.err({\n                    code: ErrorCode.InvalidRequest,\n                    details: 'Duplicate id'\n                })\n            }\n\n            const res = await models.groups.insert({ id })\n            return Result.ok({ id } as Group)\n        })\n    }\n\n    async deleteGroup(id: string): Promise<ResultType<true, RequestError>> {\n        return this.db.transaction(async (m) => {\n            const models = this.getModels(m)\n\n            const count = await models.collections.countBy({ id })\n            if (count === 0) {\n                return Result.err({\n                    code: ErrorCode.InvalidRequest,\n                    details: 'Group not exist'\n                })\n            }\n\n            await models.members.delete({ group: id })\n            await models.groups.delete({ id })\n\n            return Result.ok(true)\n        })\n    }\n\n    async addMemberToGroup(\n        user: string,\n        group: string\n    ): Promise<ResultType<true, RequestError>> {\n        return this.db.transaction(async (m) => {\n            const models = this.getModels(m)\n\n            const count = await models.collections.countBy({ id: group })\n            if (count === 0) {\n                return Result.err({\n                    code: ErrorCode.InvalidRequest,\n                    details: 'Group not exist'\n                })\n            }\n\n            const res = await models.members.insert({ user, group })\n            return Result.ok(true)\n        })\n    }\n\n    async removeMemberFromGroup(\n        user: string,\n        group: string\n    ): Promise<ResultType<true, RequestError>> {\n        return this.db.transaction(async (m) => {\n            const models = this.getModels(m)\n\n            const res = await models.members.delete({ user, group })\n            return Result.ok(true)\n        })\n    }\n}\n\nexport { Sinkron }\n","import Ajv, { JSONSchemaType } from 'ajv'\nimport { WebSocketServer, WebSocket } from 'ws'\n\nimport { Document } from \"./entities\"\nimport { Sinkron, RequestError } from \"./sinkron\"\nimport pino from 'pino'\n\nimport { Result, ResultType } from \"./result\"\nimport {\n    ErrorCode,\n    SyncMessage,\n    SyncErrorMessage,\n    SyncCompleteMessage,\n    Op,\n    ChangeMessage,\n    ModifyMessage,\n    CreateMessage,\n    DeleteMessage,\n    ErrorMessage,\n    DocMessage,\n    ClientMessage\n} from './protocol'\n\nconst syncMessageSchema = {\n    type: 'object',\n    properties: {\n        kind: { const: 'sync' },\n        // token: { type: 'string' },\n        col: { type: 'string' },\n        colrev: { type: 'integer' }\n    },\n    required: ['kind', 'col'],\n    additionalProperties: false\n}\n\nconst changeMessageSchema = {\n    type: 'object',\n    properties: {\n        kind: { const: 'change' },\n        col: { type: 'string' },\n        id: { type: 'string' },\n        changeid: { type: 'string' },\n        op: { type: 'string' },\n        data: {\n            oneOf: [\n                { type: 'string' },\n                { type: 'array', items: { type: 'string' } }\n            ]\n        }\n    },\n    required: ['kind', 'col', 'id', 'changeid', 'op'],\n    additionalProperties: false,\n    oneOf: [\n        {\n            properties: {\n                op: { const: Op.Create },\n                data: { type: 'string' }\n            },\n            required: ['data']\n        },\n        {\n            properties: {\n                op: { const: Op.Modify },\n                data: { type: 'array', items: { type: 'string' } }\n            },\n            required: ['data']\n        },\n        {\n            properties: {\n                op: { const: Op.Delete }\n            }\n        }\n    ]\n}\n\nconst clientMessageSchema = {\n    oneOf: [syncMessageSchema, changeMessageSchema]\n}\n\nconst createValidator = () => {\n    const ajv = new Ajv()\n    const validate = ajv.compile(clientMessageSchema)\n    return validate\n}\n\nconst validateMessage = createValidator()\n\ntype MessageQueueCallback<T> = (msg: T) => Promise<void>\n\nclass SequentialMessageQueue<T> {\n    constructor(callback: MessageQueueCallback<T>) {\n        this.callback = callback\n    }\n\n    messages: T[] = []\n    callback: (msg: T) => Promise<void>\n    isRunning = false\n\n    push(msg: T) {\n        this.messages.push(msg)\n        if (this.isRunning) return\n        this.isRunning = true\n        this.processMessage()\n    }\n\n    async processMessage() {\n        const msg = this.messages.shift()\n        if (msg === undefined) {\n            this.isRunning = false\n            return\n        }\n        await this.callback(msg)\n        this.processMessage()\n    }\n}\n\n\nconst serializeDate = (d: Date) => d.toISOString()\n\ntype WsMessage = [WebSocket, Buffer]\n\nconst clientDisconnectTimeout = 10000\n\ninterface SinkronServerOptions {\n    sinkron: Sinkron\n    host?: string\n    port?: number\n}\n\nconst defaultServerOptions = {\n    host: '127.0.0.1',\n    port: 8080\n}\n\nclass SinkronServer {\n    sinkron: Sinkron\n    ws: WebSocketServer\n\n    clients = new Map<WebSocket, { subscriptions: Set<string> }>()\n    collections = new Map<string, { subscribers: Set<WebSocket> }>()\n\n    logger: ReturnType<typeof pino>\n    messageQueue: SequentialMessageQueue<WsMessage>\n\n    constructor(options: SinkronServerOptions) {\n        this.logger = pino({\n            transport: { target: 'pino-pretty' }\n        })\n        this.logger.level = 'debug'\n\n        const { sinkron, host, port } = { ...defaultServerOptions, ...options }\n        this.sinkron = sinkron\n\n        this.messageQueue = new SequentialMessageQueue<WsMessage>(\n            async (msg: WsMessage) => {\n                try {\n                    await this.handleMessage(msg)\n                } catch (e) {\n                    this.logger.error(\n                        'Unhandled exception while handling message, %o',\n                        e\n                    )\n                }\n            }\n        )\n\n        this.ws = new WebSocketServer({ noServer: true })\n        this.ws.on('connection', this.onConnect.bind(this))\n    }\n\n    async onConnect(ws: WebSocket) {\n        this.logger.debug('Client connected')\n        this.clients.set(ws, { subscriptions: new Set() })\n        setTimeout(() => {\n            const client = this.clients.get(ws)\n            if (client === undefined) return\n            if (client.subscriptions.size === 0) ws.close()\n        }, clientDisconnectTimeout)\n        ws.on('message', (msg: Buffer) => this.messageQueue.push([ws, msg]))\n        ws.on('close', () => this.onDisconnect(ws))\n    }\n\n    async handleMessage([ws, msg]: WsMessage) {\n        const str = msg.toString('utf-8')\n\n        let parsed: ClientMessage\n        try {\n            parsed = JSON.parse(str.toString())\n        } catch (e) {\n            this.logger.debug('Invalid JSON in message')\n            return\n        }\n\n        this.logger.trace('Message recieved: %o', parsed)\n\n        const isValid = validateMessage(parsed)\n        if (!isValid) {\n            // TODO react something\n            this.logger.debug(\n                'Invalid message schema: %o',\n                validateMessage.errors\n            )\n            return\n        }\n\n        if (parsed.kind === 'sync') {\n            await this.handleSyncMessage(ws, parsed)\n        } else {\n            // parsed.kind === \"change\"\n            await this.handleChangeMessage(parsed, ws)\n        }\n    }\n\n    async handleSyncMessage(ws: WebSocket, msg: SyncMessage) {\n        const { col, colrev } = msg\n\n        console.log(\"HANDLE SYNC\")\n\n        // TODO error if second sync message\n\n        /*\n        const isAuthorized = await this.sinkron.verifyAuth(token)\n        if (!isAuthorized) {\n            const errorMsg: SyncErrorMessage = {\n                kind: 'sync_error',\n                col,\n                code: ErrorCode.AccessDenied\n            }\n            ws.send(JSON.stringify(errorMsg))\n            return\n        }\n        */\n\n        // TODO check collection permission\n\n        const result = await this.sinkron.syncCollection(col, colrev)\n        if (!result.isOk) {\n            const errorMsg: SyncErrorMessage = {\n                kind: 'sync_error',\n                col,\n                code: result.error.code\n            }\n            ws.send(JSON.stringify(errorMsg))\n            return\n        }\n\n        result.value.documents.forEach((doc) => {\n            const msg: DocMessage = {\n                kind: 'doc',\n                col,\n                id: doc.id,\n                // @ts-ignore\n                data: doc.data ? doc.data.toString('base64') : null,\n                createdAt: serializeDate(doc.createdAt),\n                updatedAt: serializeDate(doc.updatedAt)\n            }\n            ws.send(JSON.stringify(msg))\n        })\n\n        const syncCompleteMsg = {\n            kind: 'sync_complete',\n            col,\n            colrev: result.value.colrev\n        }\n        ws.send(JSON.stringify(syncCompleteMsg))\n\n        this.addSubscriber(msg.col, ws)\n        this.logger.debug('Client subscribed to collection %s', msg.col)\n    }\n\n    async handleChangeMessage(msg: ChangeMessage, client: WebSocket) {\n        const { op, col } = msg\n\n        // TODO check document permissions\n\n        let res: ResultType<Document, RequestError>\n        if (op === Op.Create) {\n            res = await this.handleCreateMessage(msg)\n        } else if (op === Op.Delete) {\n            res = await this.sinkron.deleteDocument(msg.id)\n        } else {\n            // if (op === Op.Modify)\n            res = await this.handleModifyMessage(msg)\n        }\n        if (!res.isOk) {\n            this.logger.debug(\n                'Failed to apply change, id: %s, error: %s, %s',\n                msg.id,\n                res.error.code,\n                res.error.details\n            )\n            const errorMsg: ErrorMessage = {\n                kind: 'error',\n                id: msg.id,\n                changeid: msg.changeid,\n                code: res.error.code\n            }\n            client.send(JSON.stringify(errorMsg))\n            return\n        }\n        const doc = res.value\n        this.logger.debug('Change applied, id: %s, op: %s', msg.id, msg.op)\n\n        const collection = this.collections.get(col)\n        if (collection) {\n            const { colrev, updatedAt, createdAt } = doc!\n            const response: ChangeMessage = { ...msg, colrev }\n            response.updatedAt = serializeDate(updatedAt)\n            if (msg.op === Op.Create) {\n                response.createdAt = serializeDate(createdAt)\n            }\n            collection.subscribers.forEach((sub) =>\n                sub.send(JSON.stringify(response))\n            )\n        }\n    }\n\n    async handleCreateMessage(msg: CreateMessage) {\n        const { id, col, data } = msg\n        return await this.sinkron.createDocument(\n            id!,\n            col,\n            Buffer.from(data, 'base64')\n        )\n    }\n\n    async handleModifyMessage(msg: ModifyMessage) {\n        const { id, col, data } = msg\n        const doc = await this.sinkron.updateDocument(\n            id,\n            data.map((c) => Buffer.from(c, 'base64'))\n        )\n        return doc\n    }\n\n    onDisconnect(ws: WebSocket) {\n        this.logger.debug('Client disconnected')\n        const client = this.clients.get(ws)\n        if (client) {\n            client.subscriptions.forEach((col) => {\n                const collection = this.collections.get(col)\n                if (collection) collection.subscribers.delete(ws)\n            })\n        }\n        this.clients.delete(ws)\n    }\n\n    addSubscriber(col: string, ws: WebSocket) {\n        const client = this.clients.get(ws)!\n\n        client.subscriptions.add(col)\n\n        const collection = this.collections.get(col)\n        if (collection) {\n            collection.subscribers.add(ws)\n        } else {\n            this.collections.set(col, { subscribers: new Set([ws]) })\n        }\n    }\n}\n\nexport { SinkronServer }\n","export type ResultType<T, E = Error> =\n    | { isOk: true; value: T }\n    | { isOk: false; error: E }\n\nconst Result = {\n    ok: <T, E>(value: T): ResultType<T, E> => ({ isOk: true, value }),\n    err: <T, E>(error: E): ResultType<T, E> => ({ isOk: false, error }),\n}\n\nexport { Result }\n\n","module.exports = require(\"@automerge/automerge\");","module.exports = require(\"@koa/router\");","module.exports = require(\"ajv\");","module.exports = require(\"koa\");","module.exports = require(\"koa-bodyparser\");","module.exports = require(\"koa-tree-router\");","module.exports = require(\"lodash\");","module.exports = require(\"pino\");","module.exports = require(\"typeorm\");","module.exports = require(\"ws\");","module.exports = require(\"http\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import path from 'node:path'\n\nimport { Sinkron, SinkronServer } from './sinkron/server'\nimport { ChangeMessage } from './sinkron/protocol'\nimport { v4 as uuidv4 } from 'uuid'\nimport * as Automerge from '@automerge/automerge'\n\nimport { App } from './paper/app'\n\ntype Doc = {\n    content: {\n        children: any[]\n    }\n    num: number\n}\n\nconst initial = {\n    content: {\n        children: [\n            {\n                type: 'paragraph',\n                children: [{ text: 'Hello' }]\n            }\n        ]\n    },\n    num: 0\n}\n\nconst dbPath = ':memory:'\n// const dbPath = \"./testdb.sqlite\"\n\nconst run = async () => {\n    const sinkron = new Sinkron({ dbPath })\n    await sinkron.init()\n\n    const app = new App({ sinkron, port: 8080 })\n    await app.init()\n\n    let user\n    const createUserResult = await app.controller.users.createUser(\n        'test',\n        'password'\n    )\n    if (createUserResult.isOk) user = createUserResult.value\n    console.log('Created user', user)\n\n    let space\n    let createSpaceResult = await app.controller.spaces.create({\n        ownerId: user!.id,\n        name: \"test\"\n    })\n    if (createSpaceResult.isOk) space = createSpaceResult.value\n    console.log('Created space', space)\n\n    let m = await app.controller.spaces.addMember({\n        userId: user!.id,\n        spaceId: space!.id,\n        role: \"admin\"\n    })\n\n\n    app.start()\n\n    /*\n    let doc = Automerge.from<Doc>(initial)\n    const [created] = await db.createDocument(\n        uuidv4(),\n        \"test\",\n        Automerge.save(doc)\n    )\n    console.log(\"CREATED\", created)\n\n    doc = Automerge.change(doc, doc => {\n        doc.num = 1\n    })\n    const change = Automerge.getLastLocalChange(doc)!\n    const [updated] = await db.updateDocument(created.id, [change])\n\n    console.log(\"UPDATED\", updated)\n\n    const docs = await db.getChangedDocuments(\"test\")\n    console.log(\"DOCS\", docs)\n\n    // const deleted = await db.deleteDocument(changed.id)\n    // console.log(\"DELETED\", deleted)\n    */\n}\n\nrun()\n"],"names":[],"sourceRoot":""}